# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qtwrbOLgvCoUwLtF83CF797HtkJyLSh-
"""

!pip install streamlit

# app_final_with_login_sqlite.py
"""
Gen AI Movie Recommendation System - Final
- TF-IDF + optional embeddings
- Gemini LLM with strict JSON enforcement + retry loop
- Email-only lightweight login
- Persistent profiles stored in SQLite
"""

import streamlit as st
import pandas as pd
import numpy as np
import sqlite3
import os
import json
import requests
import textwrap
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import normalize

st.set_page_config(page_title="Gen AI Movie Recommendation System", layout="wide")

# --------------------------
# CSS
# --------------------------
st.markdown(
    """
    <style>
    .stApp { background: linear-gradient(90deg,#071226,#001e2f); color: #e7eef8; }
    .card { background: rgba(255,255,255,0.03); border-radius:12px; padding:12px; margin-bottom:12px;}
    h1 { color: #fff !important; }
    .sidebar .stTextInput>div>input { background: rgba(255,255,255,0.04); color: #fff}
    .stButton>button { background: linear-gradient(90deg,#06b6d4,#7c3aed); color: white; border: none;}
    .big-metric { font-size: 26px; font-weight:700; color:#fff; }
    .small-muted { color: #a8c0d8; font-size:12px; }
    </style>
    """,
    unsafe_allow_html=True,
)

st.title("ðŸŽ¬ Gen AI Movie Recommendation System â€” Login + SQLite + Strict JSON Gemini")
st.markdown("Content-based + optional embeddings â†’ hybrid recommendations â†’ Gemini-powered personalized suggestions (strict JSON + retries).")

# --------------------------
# Load movies dataset
# --------------------------
@st.cache_data
def load_movies(path="movies.csv"):
    df = pd.read_csv(path)
    if "title" not in df.columns:
        st.error("movies.csv must contain a 'title' column.")
        st.stop()
    if "genres" not in df.columns:
        df["genres"] = ""
    df["title"] = df["title"].astype(str)
    df["genres"] = df["genres"].astype(str).fillna("")
    if "overview" in df.columns:
        df["overview"] = df["overview"].astype(str).fillna("")
        df["combined"] = (df["title"] + " " + df["genres"].str.replace("|", " ") + " " + df["overview"]).str.strip()
    else:
        df["combined"] = (df["title"] + " " + df["genres"].str.replace("|", " ")).str.strip()
    return df

try:
    movies = load_movies("movies.csv")
except Exception as e:
    st.error("Could not load movies.csv. Put it in same directory. Error: " + str(e))
    st.stop()

# --------------------------
# Sidebar: Gemini + options
# --------------------------
st.sidebar.header("LLM (Gemini) & Settings")
gemini_api_key = st.sidebar.text_input("Paste your Gemini API key (x-goog-api-key)", type="password")
gemini_model = st.sidebar.selectbox("Gemini model (REST)", options=[
    "gemini-2.5-flash", "gemini-2.1", "gemini-1.5-pro", "gemini-1.5-flash"
], index=0)
max_tokens = st.sidebar.slider("LLM max tokens (approx)", 64, 1024, 256, step=64)
max_retries = st.sidebar.slider("Gemini JSON parsing retries", 1, 5, 3)

st.sidebar.markdown("---")
st.sidebar.header("Similarity options")
use_embeddings = st.sidebar.checkbox("Use sentence-transformers embeddings (if installed)", value=False)
hybrid_mode = st.sidebar.checkbox("Use hybrid TF-IDF + embeddings scoring", value=False)
st.sidebar.markdown("If embeddings aren't available the app falls back to TF-IDF.")

# --------------------------
# Optional: sentence-transformers
# --------------------------
embedding_model = None
if use_embeddings:
    try:
        from sentence_transformers import SentenceTransformer
        embedding_model = SentenceTransformer("all-MiniLM-L6-v2")
        st.sidebar.success("sentence-transformers loaded (all-MiniLM-L6-v2).")
    except Exception as e:
        st.sidebar.error("sentence-transformers not available. Falling back to TF-IDF.")
        use_embeddings = False
        hybrid_mode = False

# --------------------------
# TF-IDF fit
# --------------------------
@st.cache_data
def fit_tfidf(corpus, max_features=20000):
    v = TfidfVectorizer(stop_words="english", max_features=max_features)
    X = v.fit_transform(corpus)
    return v, X

tf_vectorizer, X_tfidf = fit_tfidf(movies["combined"].tolist())

# embeddings
if use_embeddings:
    @st.cache_data
    def compute_embeddings(corpus):
        embs = embedding_model.encode(corpus, show_progress_bar=False, convert_to_numpy=True)
        return normalize(embs)
    X_emb = compute_embeddings(movies["combined"].tolist())
else:
    X_emb = None

# kNN models
@st.cache_data
def fit_knn(_matrix, metric="cosine"):
    nn = NearestNeighbors(metric=metric, algorithm="brute")
    nn.fit(_matrix)
    return nn

knn_tfidf = fit_knn(X_tfidf, metric="cosine")
knn_emb = fit_knn(X_emb, metric="cosine") if X_emb is not None else None

# --------------------------
# SQLite DB for profiles
# --------------------------
DB_PATH = "profiles.db"

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
    CREATE TABLE IF NOT EXISTS users (
        email TEXT PRIMARY KEY,
        liked_json TEXT,
        disliked_json TEXT,
        preferred_genres_json TEXT
    )
    """)
    conn.commit()
    conn.close()

init_db()

def save_profile_db(email, liked, disliked, preferred_genres):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("REPLACE INTO users (email, liked_json, disliked_json, preferred_genres_json) VALUES (?, ?, ?, ?)",
              (email, json.dumps(liked), json.dumps(disliked), json.dumps(preferred_genres)))
    conn.commit()
    conn.close()

def load_profile_db(email):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT liked_json, disliked_json, preferred_genres_json FROM users WHERE email = ?", (email,))
    row = c.fetchone()
    conn.close()
    if row:
        liked = json.loads(row[0]) if row[0] else {}
        disliked = json.loads(row[1]) if row[1] else []
        preferred = json.loads(row[2]) if row[2] else []
        return {"liked": liked, "disliked": disliked, "preferred_genres": preferred}
    return None

def list_user_emails():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT email FROM users")
    rows = c.fetchall()
    conn.close()
    return [r[0] for r in rows]

# --------------------------
# Session state
# --------------------------
if "email" not in st.session_state:
    st.session_state.email = None
if "liked" not in st.session_state:
    st.session_state.liked = {}
if "disliked" not in st.session_state:
    st.session_state.disliked = []
if "preferred_genres" not in st.session_state:
    st.session_state.preferred_genres = []

# --------------------------
# Tabs
# --------------------------
tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
    "ðŸ“˜ Data",
    "ðŸ”§ Features",
    "ðŸ“Š Visuals",
    "ðŸ¤– Content Recs",
    "ðŸ§  Gemini LLM (Strict JSON)",
    "ðŸ“ˆ Profiles & Eval"
])

# --------------------------
# TAB 1: Data
# --------------------------
with tab1:
    st.header("ðŸ“˜ Data")
    st.dataframe(movies[["title", "genres"]].head(10))
    st.markdown(f"Rows: **{movies.shape[0]}**  Columns: **{movies.shape[1]}**")

# --------------------------
# TAB 2: Features
# --------------------------
with tab2:
    st.header("ðŸ”§ Feature Engineering")
    st.write("TF-IDF matrix shape:", X_tfidf.shape)
    if X_emb is not None:
        st.write("Embeddings shape:", X_emb.shape)

# --------------------------
# TAB 3: Visuals
# --------------------------
with tab3:
    st.header("ðŸ“Š Visuals")
    genres_series = movies["genres"].str.replace("|", " ").str.split().explode()
    top_genres = genres_series.value_counts().head(20)
    fig, ax = plt.subplots(figsize=(10,4))
    top_genres.plot(kind="bar", ax=ax)
    ax.set_xlabel("Genre"); ax.set_ylabel("Count")
    st.pyplot(fig)
    plt.clf()

# --------------------------
# TAB 4: Content Recs
# --------------------------
from sklearn.metrics.pairwise import cosine_similarity
with tab4:
    st.header("ðŸ¤– Content-based Recommendations")
    movie_choice = st.selectbox("Pick a movie for content recs", movies["title"].tolist())
    k = st.slider("Number of recommendations", 1, 20, 6)
    idx = movies.index[movies["title"] == movie_choice][0]

    d_tfidf, i_tfidf = knn_tfidf.kneighbors(X_tfidf[idx], n_neighbors=k+1)
    rec_idx = i_tfidf[0][1:]
    recs = movies.iloc[rec_idx][["title", "genres"]].copy()
    recs["tfidf_similarity"] = (1 - d_tfidf[0][1:]).round(4)

    if X_emb is not None and hybrid_mode:
        # hybrid: compute similarity across all via embeddings + TF-IDF low-dim
        emb_sims = cosine_similarity([X_emb[idx]], X_emb)[0]
        try:
            # approximate TF-IDF sims via dot on normalized SVD or compute cosine against dense representation
            tfidf_dense = None
            from sklearn.decomposition import TruncatedSVD
            tfidf_dense = TruncatedSVD(n_components=128, random_state=42).fit_transform(X_tfidf)
            tfidf_dense = normalize(tfidf_dense)
            tfidf_sims = cosine_similarity([tfidf_dense[idx]], tfidf_dense)[0]
            hybrid = 0.5 * emb_sims + 0.5 * tfidf_sims
            hybrid[idx] = -1
            top_idx = np.argsort(hybrid)[-k:][::-1]
            recs = movies.iloc[top_idx][["title", "genres"]].copy()
            recs["hybrid_score"] = hybrid[top_idx].round(4)
            st.subheader("Hybrid recommendations (embeddings + TF-IDF)")
            st.table(recs.reset_index(drop=True))
        except Exception:
            st.warning("Hybrid fallback failed; showing TF-IDF results.")
            st.subheader("TF-IDF content-based recommendations")
            st.table(recs.reset_index(drop=True))
    else:
        st.subheader("TF-IDF content-based recommendations")
        st.table(recs.reset_index(drop=True))

    # Quick add to profile (if logged in)
    st.markdown("---")
    st.subheader("Quick add recommended movies to your profile")
    if st.session_state.email:
        for title in recs["title"].tolist():
            cols = st.columns([4,1,1])
            cols[0].write(f"**{title}**")
            if cols[1].button(f"Like {title}", key=f"like_q_{title}"):
                st.session_state.liked[title] = st.session_state.liked.get(title, 8)
            if cols[2].button(f"Dislike {title}", key=f"dis_q_{title}"):
                if title not in st.session_state.disliked:
                    st.session_state.disliked.append(title)
        st.success("Use the Profiles tab to save changes permanently.")
    else:
        st.info("Login (email) in the Profiles tab to enable quick-add to your profile.")

# --------------------------
# Helper: build strict JSON prompt
# --------------------------
def build_strict_json_prompt(target, similar_list, liked_dict, disliked_list, preferred_genres):
    # ask Gemini to return strict JSON and include a short validation token
    prompt = textwrap.dedent(f"""
    You are a strict, machine-readable movie recommender.  **Return valid JSON only** â€” nothing else.

    INPUT:
    - Target movie: "{target}"
    - Similar movies (content-based): {json.dumps(similar_list)}
    - User liked movies with ratings: {json.dumps(liked_dict)}
    - User disliked movies: {json.dumps(disliked_list)}
    - Preferred genres: {json.dumps(preferred_genres)}

    TASK:
    Suggest exactly 5 movie recommendations. For each recommendation output:
      {{
        "title": "<movie title>",
        "reason": "<one-line reason, 2-20 words>"
      }}
    Return exactly a JSON array of 5 objects, for example:
    [
      {{ "title": "Movie A", "reason": "short reason" }},
      ...
    ]

    IMPORTANT:
    - Do NOT include any commentary, prose, or text around the JSON.
    - If you cannot produce valid JSON, respond with the single exact token: INVALID_JSON
    """).strip()
    return prompt

# --------------------------
# Function: call Gemini with retries until valid JSON or attempts exhausted
# --------------------------
def call_gemini_with_json_response(prompt_text, api_key, model, max_tokens, retries=3):
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
    headers = {"Content-Type": "application/json", "x-goog-api-key": api_key}
    body = {
        "contents": [
            {"role": "user", "parts": [{"text": prompt_text}]}
        ],
        "temperature": 0.7,
        "maxOutputTokens": max_tokens
    }

    attempt = 0
    last_resp = None
    while attempt < retries:
        attempt += 1
        try:
            resp = requests.post(url, headers=headers, json=body, timeout=30)
            last_resp = resp
            if resp.status_code != 200:
                # non-200, return error info
                return {"error": f"HTTP {resp.status_code}", "resp_text": resp.text}
            j = resp.json()
            # robustly extract text output from common shapes
            def find_text(obj):
                if isinstance(obj, str):
                    return obj
                if isinstance(obj, dict):
                    for k,v in obj.items():
                        r = find_text(v)
                        if r:
                            return r
                if isinstance(obj, list):
                    for item in obj:
                        r = find_text(item)
                        if r:
                            return r
                return None
            # try candidates->content->text
            text = None
            if "candidates" in j and isinstance(j["candidates"], list) and j["candidates"]:
                cand = j["candidates"][0]
                if isinstance(cand, dict) and "content" in cand:
                    for c in cand["content"]:
                        if isinstance(c, dict) and "text" in c:
                            text = c["text"]
                            break
                if not text and "output" in cand:
                    text = find_text(cand["output"])
            if not text:
                text = find_text(j)

            if not text:
                # nothing to parse
                if attempt < retries:
                    # send clarifying follow-up by slightly modifying prompt to emphasize strict JSON (we do another POST)
                    prompt_text = prompt_text + "\n\nREMINDER: Output exactly valid JSON or the token INVALID_JSON."
                    continue
                else:
                    return {"error": "No text found in Gemini response", "raw_json": j}

            # check for special INVALID_JSON token
            if text.strip() == "INVALID_JSON":
                if attempt < retries:
                    prompt_text = prompt_text + "\n\nYou previously returned INVALID_JSON. Try again and ensure only valid JSON array is returned."
                    continue
                else:
                    return {"error": "LLM returned INVALID_JSON", "raw_text": text, "raw_json": j}

            # try to extract JSON array substring
            start = text.find("[")
            end = text.rfind("]") + 1
            if start != -1 and end != -1 and end > start:
                json_str = text[start:end]
                try:
                    parsed = json.loads(json_str)
                    # verify it's a list of length 5 with objects containing title & reason
                    if isinstance(parsed, list) and len(parsed) == 5 and all(isinstance(it, dict) for it in parsed):
                        return {"parsed": parsed, "raw_text": text, "raw_json": j}
                    else:
                        # invalid shape
                        if attempt < retries:
                            prompt_text = prompt_text + "\n\nYour JSON did not match the required shape. Return exactly 5 objects with title and reason."
                            continue
                        else:
                            return {"error": "Parsed JSON shape invalid", "parsed": parsed, "raw_text": text}
                except Exception as e:
                    # JSON parse failed
                    if attempt < retries:
                        prompt_text = prompt_text + "\n\nYour last output could not be parsed as JSON. Return only valid JSON now."
                        continue
                    else:
                        return {"error": "JSON parse error", "exception": str(e), "raw_text": text}
            else:
                # no JSON bracket found
                if attempt < retries:
                    prompt_text = prompt_text + "\n\nWe could not find a JSON array in your output. Please return EXACTLY a JSON array of 5 objects."
                    continue
                else:
                    return {"error": "No JSON array found in text", "raw_text": text}
        except requests.exceptions.RequestException as e:
            return {"error": "RequestException", "exception": str(e)}
    # fallback
    return {"error": "Retries exhausted", "last_response": last_resp.text if last_resp is not None else None}

# --------------------------
# TAB 5: Gemini LLM with strict JSON + login
# --------------------------
with tab5:
    st.header("ðŸ§  Gemini LLM â€” Strict JSON + Login")
    st.markdown("Login with email to separate profiles. Gemini will be asked to return strict JSON. The app will retry automatically until valid JSON or retries exhausted.")

    # Login / register (email only)
    col1, col2, col3 = st.columns([3,1,1])
    with col1:
        email_input = st.text_input("Enter your email to log in / create profile", value=st.session_state.email or "")
    with col2:
        if st.button("Login"):
            if not email_input or "@" not in email_input:
                st.error("Enter a valid email.")
            else:
                st.session_state.email = email_input
                # load profile if exists
                profile = load_profile_db(email_input)
                if profile:
                    st.session_state.liked = profile.get("liked", {})
                    st.session_state.disliked = profile.get("disliked", [])
                    st.session_state.preferred_genres = profile.get("preferred_genres", [])
                    st.success(f"Loaded profile for {email_input}.")
                else:
                    # initialize empty profile and save
                    st.session_state.liked = {}
                    st.session_state.disliked = []
                    st.session_state.preferred_genres = []
                    save_profile_db(email_input, st.session_state.liked, st.session_state.disliked, st.session_state.preferred_genres)
                    st.success(f"Created new profile for {email_input}.")
    with col3:
        if st.button("Logout"):
            st.session_state.email = None
            st.session_state.liked = {}
            st.session_state.disliked = []
            st.session_state.preferred_genres = []
            st.success("Logged out (session cleared).")

    st.markdown("---")
    st.write("Current logged-in email:", st.session_state.email or "Not logged in")
    st.write("Liked:", st.session_state.liked)
    st.write("Disliked:", st.session_state.disliked)
    st.write("Preferred genres:", st.session_state.preferred_genres)

    st.markdown("---")
    # Preference UI
    st.subheader("Preferences (used by LLM prompt)")
    colA, colB = st.columns(2)
    with colA:
        add_like_title = st.selectbox("Add liked movie", [""] + movies["title"].tolist(), key="add_like2")
        like_rating = st.slider("Rating (1-10)", 1, 10, 8, key="like_rating2")
        if st.button("Add liked movie to profile"):
            if not st.session_state.email:
                st.error("Log in first.")
            elif add_like_title:
                st.session_state.liked[add_like_title] = like_rating
                st.success(f"Added liked: {add_like_title} ({like_rating})")
    with colB:
        add_dislike_title = st.selectbox("Add disliked movie", [""] + movies["title"].tolist(), key="add_dislike2")
        if st.button("Add disliked movie to profile"):
            if not st.session_state.email:
                st.error("Log in first.")
            elif add_dislike_title:
                if add_dislike_title not in st.session_state.disliked:
                    st.session_state.disliked.append(add_dislike_title)
                    st.success(f"Added disliked: {add_dislike_title}")

    # Preferred genres
    all_genres = sorted(set(movies["genres"].str.replace("|", " ").str.split().explode().dropna().unique()))
    chosen_genres = st.multiselect("Preferred genres", all_genres, default=st.session_state.preferred_genres)
    st.session_state.preferred_genres = chosen_genres

    # Save profile button
    if st.button("Save profile to DB"):
        if not st.session_state.email:
            st.error("Log in first.")
        else:
            save_profile_db(st.session_state.email, st.session_state.liked, st.session_state.disliked, st.session_state.preferred_genres)
            st.success("Profile saved to database.")

    st.markdown("---")
    st.subheader("Target movie & context for LLM")
    target_movie = st.selectbox("Pick target movie (context)", movies["title"].tolist())
    idx_target = movies.index[movies["title"] == target_movie][0]
    d_tfidf, i_tfidf = knn_tfidf.kneighbors(X_tfidf[idx_target], n_neighbors=8)
    similar_ctx = movies.iloc[i_tfidf[0][1:6]]["title"].tolist()
    st.write("Similar movies used as context:", similar_ctx)

    st.markdown("---")
    st.subheader("Generate strict-JSON LLM recommendations")
    # build prompt with current profile
    prompt_text = build_strict_json_prompt(target_movie, similar_ctx, st.session_state.liked, st.session_state.disliked, st.session_state.preferred_genres)
    prompt_edit = st.text_area("Prompt sent to Gemini (editable)", value=prompt_text, height=260)

    if st.button("Generate recommendations (Gemini -> strict JSON)"):
        if not gemini_api_key:
            st.error("Provide Gemini API key in sidebar.")
        elif not st.session_state.email:
            st.error("Log in with email first to tie recommendations to profile.")
        else:
            with st.spinner("Calling Gemini and validating JSON..."):
                result = call_gemini_with_json_response(prompt_edit, gemini_api_key, gemini_model, max_tokens, retries=max_retries)
                if "error" in result:
                    st.error("Gemini JSON validation failed: " + str(result.get("error")))
                    if "raw_text" in result:
                        st.markdown("**Last LLM raw text:**")
                        st.text(result.get("raw_text"))
                    if "raw_json" in result:
                        st.markdown("**Last LLM JSON:**")
                        st.json(result.get("raw_json"))
                else:
                    parsed = result.get("parsed")
                    st.success("Received valid JSON recommendations from Gemini.")
                    st.table(pd.DataFrame(parsed))
                    # quick add buttons
                    st.markdown("Quick-add these recommendations to your profile:")
                    for rec in parsed:
                        title = rec.get("title")
                        reason = rec.get("reason")
                        cols = st.columns([4,1,1])
                        cols[0].write(f"**{title}** â€” {reason}")
                        if cols[1].button(f"Like {title}", key=f"ll_like_{title}"):
                            st.session_state.liked[title] = st.session_state.liked.get(title, 8)
                        if cols[2].button(f"Dislike {title}", key=f"ll_dis_{title}"):
                            if title not in st.session_state.disliked:
                                st.session_state.disliked.append(title)
                    # Save to DB automatically as convenience
                    save_profile_db(st.session_state.email, st.session_state.liked, st.session_state.disliked, st.session_state.preferred_genres)
                    st.info("Profile auto-saved to DB after recommendations.")

# --------------------------
# TAB 6: Profiles & Eval
# --------------------------
with tab6:
    st.header("ðŸ“ˆ Profiles & Evaluation")
    st.subheader("All saved user emails")
    st.write(list_user_emails())
    st.markdown("---")
    st.subheader("Current session profile")
    st.write("Email:", st.session_state.email)
    st.write("Liked:", st.session_state.liked)
    st.write("Disliked:", st.session_state.disliked)
    st.write("Preferred genres:", st.session_state.preferred_genres)
    if st.button("Clear in-memory profile (logout style)"):
        st.session_state.email = None
        st.session_state.liked = {}
        st.session_state.disliked = []
        st.session_state.preferred_genres = []
        st.success("Cleared session profile.")

    st.markdown("---")
    st.subheader("Evaluation: neighbor distance distribution (TF-IDF)")
    sample_n = st.number_input("Sample size", 50, 500, 200)
    idxs = np.random.choice(X_tfidf.shape[0], min(sample_n, X_tfidf.shape[0]), replace=False)
    dists = []
    for i in idxs:
        ds, ids = knn_tfidf.kneighbors(X_tfidf[i], n_neighbors=2)
        dists.append(float(ds[0][1]))
    st.metric("Average nearest-neighbor cosine distance", f"{np.mean(dists):.4f}")
    fig, ax = plt.subplots(figsize=(8,3))
    sns.histplot(dists, kde=True, ax=ax)
    st.pyplot(fig)

st.markdown("---")
st.markdown("**Notes:**\n- The app asks Gemini to return strict JSON. If Gemini fails to do so, the app retries (up to the configured number of retries). \n- Profiles are stored in a local SQLite DB (`profiles.db`) keyed by email. \n- Keep your Gemini API key private. If you'd like the key stored more securely, we can switch to `st.secrets` or environment variables.")